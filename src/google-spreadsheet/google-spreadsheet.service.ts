import {
  Injectable,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { GoogleSpreadsheet } from 'google-spreadsheet';
import { JWT } from 'google-auth-library';
import { ConfigService } from '@nestjs/config';
import { RedisService } from '../redis/redis.service';

@Injectable()
export class GoogleSpreadsheetService {
  constructor(
    private readonly configService: ConfigService,
    private readonly redisService: RedisService,
  ) {}

  logger = new Logger(GoogleSpreadsheetService.name);

  serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    key: process.env.GOOGLE_PRIVATE_KEY.split(String.raw`\n`).join('\n'),
    scopes: ['https://www.googleapis.com/auth/spreadsheets'],
  });

  async getData() {
    try {
      const sheetId = this.configService.get<string>('GOOGLE_SHEET_ID');
      const doc = new GoogleSpreadsheet(sheetId, this.serviceAccountAuth);

      await doc.loadInfo();

      // check if gsheet has valid data
      const configValues = await this.getConfigGSheet(doc);

      const competitionData = await this.getCompetitionData(doc);
      const masterStoreData = await this.getMasterStoreData(doc);

      // validating which match up result to pull from redis
      const competitionIds = await this.validateMatchupSheetToPull(
        competitionData,
        doc,
      );
      console.log(competitionIds);

      const resultStageGroupData = await this.getResultStageGroup(
        doc,
        competitionIds.pull,
      );

      this.logger.log('Finished get data from sheet');

      // clear redis data
      await this.redisService.clearAll(competitionIds.pull, 'Matchup');

      // set newest data to redis
      await this.redisService.set('competition', competitionData);
      await this.redisService.set('config', configValues);
      await this.redisService.set('store', masterStoreData);

      for (const data of resultStageGroupData) {
        await this.redisService.set(data.id, data.values);
      }

      return {
        message: 'Finished get data from sheet',
      };
    } catch (error) {
      this.logger.error(`Error when get sheet data ${error}`);
      throw new InternalServerErrorException();
    }
  }

  async getConfigGSheet(doc: GoogleSpreadsheet, retryCount = 0) {
    try {
      this.logger.log(`Trying to get config google sheet`);

      const sheet = doc.sheetsByTitle['Config'];
      const rows = await sheet.getRows();

      const values: Array<Array<string>> = [];

      values.push(sheet.headerValues);

      for (const row of rows) {
        values.push(row['_rawData']);
      }
      // value sales update data at index 5 then at index 1
      const salesUpdateTime = values[5][1];

      if (!salesUpdateTime) {
        const maxRetries = 5; // Adjust the maximum number of retries as needed
        if (retryCount < maxRetries) {
          const delayInSeconds = this.calculateDelay(retryCount);
          this.logger.log(
            `Sales update time is null in config sheet. Waiting ${delayInSeconds} seconds before retrying...`,
          );
          await new Promise((resolve) =>
            setTimeout(resolve, delayInSeconds * 1000),
          ); // Wait before retrying
          return this.getConfigGSheet(doc, retryCount + 1); // Retry with incremented retry count
        } else {
          throw new Error(
            `Max retry count (${maxRetries}) reached. Sales update time is null.`,
          );
        }
      }

      return values;
    } catch (error) {
      this.logger.error(`Error while get config google sheet ${error}`);
      throw new InternalServerErrorException();
    }
  }

  async getCompetitionData(doc: GoogleSpreadsheet) {
    try {
      this.logger.log('Trying to get Competition Data');

      const sheet = doc.sheetsByTitle['Competition'];
      const rows = await sheet.getRows();

      const values: Array<Array<string>> = [];

      values.push(sheet.headerValues);

      for (const row of rows) {
        values.push(row['_rawData']);
      }

      return values;
    } catch (error) {
      this.logger.error(`Error when get Competition data ${error}`);
      throw new InternalServerErrorException();
    }
  }

  async getMasterStoreData(doc: GoogleSpreadsheet) {
    try {
      this.logger.log('Trying to get Store Data');

      const sheet = doc.sheetsByTitle['MasterStore'];

      const rows = await sheet.getRows();

      const values: Array<Array<string>> = [];

      values.push(sheet.headerValues);

      for (const row of rows) {
        values.push(row['_rawData']);
      }

      return values;
    } catch (error) {
      this.logger.error(`Error when get Master Store data ${error}`);
      throw new InternalServerErrorException();
    }
  }

  async getResultStageGroup(
    doc: GoogleSpreadsheet,
    sheetIdToBePulled?: string[],
  ) {
    try {
      const values: {
        id: string;
        values: any[];
      }[] = [];
      let competitionStageGroupId: string[] = [];

      const prefixResult = 'Matchup';
      const sheetTitles = doc.sheetsByTitle;

      if (!sheetIdToBePulled.length) {
        // Filter sheet titles concurrently
        competitionStageGroupId = await Promise.all(
          Object.keys(sheetTitles).filter((s) => s.startsWith(prefixResult)),
        );
      } else {
        let ids: string[];
        for (const id of sheetIdToBePulled) {
          ids = Object.keys(sheetTitles).filter((s) =>
            s.startsWith(`${prefixResult}-${id}`),
          );

          competitionStageGroupId.push(...ids);
        }
      }

      // Batch sheet calls and Redis interactions
      const batchSize = 1; // Adjust as needed
      for (let i = 0; i < competitionStageGroupId.length; i += batchSize) {
        const batch = competitionStageGroupId.slice(i, i + batchSize);
        const sheetDataPromises = batch.map(async (id) => {
          this.logger.log(`Trying to get Matchup Data for ${id}`);

          const sheet = doc.sheetsByTitle[id];
          const rows = await sheet.getRows(); // Load only necessary rows if possible
          const values = [
            sheet.headerValues,
            ...rows.map((row) => row['_rawData']),
          ];
          return { id, values };
        });

        const sheetData = await Promise.all(sheetDataPromises);

        values.push(...sheetData);
        await new Promise((resolve) => setTimeout(resolve, 1.8 * 1000));
      }

      return values;
    } catch (error) {
      this.logger.error(`Error when get Matchup data ${error}`);
      throw new InternalServerErrorException();
    }
  }

  async validateMatchupSheetToPull(
    competition: string[][],
    doc: GoogleSpreadsheet,
  ) {
    try {
      const header = competition[0][22];
      let isAllCompetitionFinish = false;

      // remove header
      competition.shift();
      console.log(header);
      const prefixResult = 'Matchup';
      const sheetTitles = doc.sheetsByTitle;

      // Filter sheet titles concurrently
      const matchupSheetIds = await Promise.all(
        Object.keys(sheetTitles).filter((s) => s.startsWith(prefixResult)),
      );

      const regexedMatchupSheetId = matchupSheetIds.map((item) => {
        const match = item.match(/Matchup-(.*)-Group/);

        if (match) {
          const extractedString = match[1].replace(/-/g, '_'); // Replace all occurrences of hyphens with underscores
          return extractedString;
        } else {
          return null;
        }
      });

      console.log({
        competition: matchupSheetIds.length,
        regex: regexedMatchupSheetId,
      });

      // competition id in competition at index 0
      // finished status at index 22
      const finished: string[] = []; // finished stage
      const pull: string[] = []; // not yet finished stage

      for (const comp of competition) {
        // inform to be
        if (comp[22] === '1') {
          finished.push(comp[0].replace(/_/g, '-'));
        } else {
          pull.push(comp[0].replace(/_/g, '-'));
        }
      }

      //TODO: check ketika ada data matchup di redis tapi di google sheet tidak ada, hapus data di redis
      // get all redis key for match up
      const localRedisMatchupKeys = await this.redisService.getKeys(
        prefixResult,
      );

      console.log({ localRedisMatchupKeys });

      console.log({
        finish: finished.length,
        allComp: competition.length,
      });
      if (finished.length == competition.length) {
        isAllCompetitionFinish = true;
      }

      return {
        finished,
        pull,
        isAllCompetitionFinish,
      };
    } catch (error) {
      this.logger.error(
        `Error when validate which match up sheet to pull from gsheet ${error}`,
      );
      throw new InternalServerErrorException();
    }
  }

  calculateDelay(retryCount: number): number {
    const baseDelay = 5; // Base delay in seconds
    const exponentialFactor = 2; // Exponential factor for increasing delay
    return baseDelay * Math.pow(exponentialFactor, retryCount);
  }
}
